---
title: 'test'
date: '2020-01-02'
imageUrl: '/blog1.webp'

---

thanks reference
https://raw.githubusercontent.com/gaearon/overreacted.io/master/src/pages/a-complete-guide-to-useeffect/index.ja.md

あなたは Hooks を使って複数のコンポーネントを書きました。ちょっとしたアプリも作ったことがあるでしょう。満足もしている。API にも慣れて、その過程でコツも掴んできました。しかも重複したロジックを転用できるよう Custom Hooks を作り、同僚に自慢して見たり。

でも useEffect を使う度、いまいちピンときません。class のライフサイクルとは似ているけど、何かが違う。そしていろんな疑問を抱き始めます。


- 🤔 `componentDidMount` を `useEffect` で再現する方法は？
- 🤔 `useEffect` 内で正確に非同期処理を行う方法とは？　`[]`ってなに？
- 🤔 関数をエフェクトの依存関係として記すべき？
- 🤔 非同期処理の無限ループがたまに起こるのはなぜ？
- 🤔 古い state か props がエフェクト内にたまに入るのはなぜ？

私も Hooks を使い始めた時、同じような疑問を抱いてました。ドキュメントを書き始めた時も、まだ完璧に理解していませんでした。今回は、私がその後経験した アハモーメントを共有します。**この記事を読むことによって、上記に挙げた質問を当たり前にわかるようになるでしょう。**

答えが見えるようになるには、一歩下がって全体図を俯瞰して理解する必要があります。この記事の目的は箇条書きで答えを教えることではなく、 `useEffect` を完璧に理解していただくことです。習うことはそれほど多くはありません。それどころか、覚えていることを意識的に忘れることに注力していきます。

**`useEffect` Hook を慣れている class のライフサイクルパラダイムと分離して初めて理解できました。**

> “覚えたことを全て忘れるのじゃ.” — Yoda

![空気を嗅ぐヨーダ. キャプション: “ベーコンの匂いがする.”](./yoda.jpg)

---

**この記事は [`useEffect`](https://ja.reactjs.org/docs/hooks-effect.html) API をある程度理解していることが前提です**

**しかも*すごい*長文です。小さな本並みです。私が個人的に好むフォーマットなので、もし急ぎもしくはそこまで興味ない場合は、下に TLDR を書いたのでそちらを読んでください**

**もしこのようなディープダイブがしっくりこない場合は、他で説明されるのを待ったほうがいいかもしれません。React が 2013 年に出た時と同じように、人々が新たなメンタルモデルを理解して教えるのには時間がかかります。**

--

## TLDR（長すぎ、読んでない）

このセクションには全てを読みたくない人向けに簡潔に質問に答えています。理解できない部分があれば、下にスクロールしてその部分に関係あるところを読んでください。

この記事を全て読むのであれば遠慮なくこのセクションは飛ばしてください。最後にリンクを貼ります。

**🤔 `componentDidMount`を`useEffect`で再現する方法は？**

`useEffect(fn, [])` でも再現できますが、全く同じという訳ではありません。 `componentDidMount` とは違い、props と state を*キャプチャー*します。なので、callback の中でも初期 props と state を参照できます。一番最新のなにかを参照したい場合は、ref として書けます。ですが大概は ref として書かなくてもいいようコードを構成する方法があります。覚えて欲しいことは、effects と `componentDidMount` や他のライフサイクルメソッドのメンタルモデルは別であることです。なので、それぞれのライフサイクルメソッドの代用を探そうとすると余計に混乱してしまいます。効率的になるためには「エフェクトで考える」必要があり、そのメンタルモデルはライフサイクルイベントに反応することではなく props や state の変化を DOM にシンクロさせる、という方に近いです。

**🤔 `useEffect` 内で正確に非同期処理を行う方法とは？ `[]` ってなに？**

この[記事](https://www.robinwieruch.de/react-hooks-fetch-data/)を参考にしてみると良いでしょう。最後まで読むように！この記事ほど長くはありません。`[]`は、エフェクトは React のデータフローに携わる値をなに一つ使用していないので、一度だけ実行しても良いということを示していてます。ですが値が実際にエフェクト内で*使用*されている場合はバグの根源ともなります。依存関係を解消して正しく値を省くには複数のテクニック（主に `useReducer` と `useCallback` ）を用いる必要があります。

**🤔 関数をエフェクトの依存関係として記すべき？**

推薦される方法としては props や state を必要としない関数は*コンポーネント外*にホイスティングして、エフェクトでしか使われない関数は*エフェクト内*に入れる方法です。しかしそのあとにもエフェクトがレンダースコープ内の関数を使うことがあるのであれば（props からの関数も含む）、 `useCallback` で関数が定義されている場所をラップしてそのプロセスをリピートします。なぜそれが大事かというと、関数は props や state を*見る*ことができるので、React のデータフローに携わるからです。詳しくは[FAQ](https://reactjs.org/docs/hooks-faq.html#is-it-safe-to-omit-functions-from-the-list-of-dependencies)を参照してください。

**🤔 非同期処理の無限ループがたまに起こるのはなぜ？**

エフェクト内で非同期処理を依存関係を表す第二引数を与えないで実行すると起こります。第二引数がない場合、エフェクトは毎 render 時に走り、内部で state をセットしてると再度エフェクトをトリガーするからです。依存関係を表す第二引数に*常に*変わる値が入ってる場合でも無限ループは起きます。どれが問題の原因かは依存配列の中から値を一つ一つ削除していくことによって分かります。ですが、エフェクト内で使用してる値を依存配列から取り出したり（もしくは闇雲に `[]` を指定したり）するのは大概の場合、正しくない直し方です。その代わり、問題の根源から直していきましょう。例えば、関数などがこの問題を起こしがちで、エフェクト内に定義するか、ホイスティングするか `useCallback` でラップすると良いかもしれません。オブジェクトの再生成を阻止するために使われる `useMemo` も同じような用途で使えます。

**🤔 古い state か props がエフェクト内にたまに入るのはなぜ？**

エフェクトは必ず定義された render の props と state を見ることができます。この方法は[バグを阻止するのに有効](/how-are-function-components-different-from-classes/)ですが、厄介と感じるケースもあります。その場合は、明確に値を mutable ref に保存すると良いでしょう（リンクされている記事の最後の方で説明してます）。もし古いレンダーからpropsやstateを参照して値が期待通りでないと考えたのなら、依存配列に何か入れ忘れている可能性があります。この[lint ルール](https://github.com/facebook/react/issues/14920)を使って、入れ忘れないように慣れましょう。使い始めて数日経てば、習慣になるはずです。こちらの[FAQ](https://reactjs.org/docs/hooks-faq.html#why-am-i-seeing-stale-props-or-state-inside-my-function)にも答えてるので参照してみてください。

---

この TLDR が役に立ったなら嬉しいです。そうでなければ、深入りしていきましょう。

---

## それぞれの render は独自の props と state を保持している

エフェクトに関して話す前に、レンダーリングについて話す必要があります。

まず、ここにはカウンターがあります。ハイライトされた行を見てください：

```jsx
function Counter() {
  const [count, setCount] = useState(0);

  return (
    <div>
      <p>You clicked {count} times</p>
      <button onClick={() => setCount(count + 1)}>Click me</button>
    </div>
  );
}
```

```js
return Scaffold(
  appBar:AppBar(),
  body:Container(),
);
```

